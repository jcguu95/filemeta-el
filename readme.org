* filemeta.el

This program aims to help users add notes to their files.

It mimics the design of =git= in that it creates a sub-directory
=.filemeta= in the directory that is initiated. =.filemeta= serves as
the database for this directory. Upon a file is called to be
annotated, a function will look for where the root of the current
=filemeta= repo is, by recursively searching upward.

Within a =filemeta= repo, while a file is called to be operated,
its md5sum would be calculated. Then, its relative path, hash,
and the current time will be recorded. All annotations are
assigned to the hashes, but not the paths. That means, if the
file is moved or renamed, with its content unchanged, this
program =filemeta= will can still identify and make further
changes.

This approach has at least two drawbacks. One, directories should
be handled differently from regular files. Two, if the content is
changed, something needs to be done to identify the file.

For the second issue, namely while the relative path turns out to
have different contents from what's recorded in the history,
=filemeta= will signal a warning, and ask the users what to do
next. There are a few options.

1. Search recursively in the repo to find the file with the same
   hash (this could be expensive).
2. Merge the data for the old hash to this new hash.

Below are some internals.

** database (attachment)

#+begin_src elisp
;; attachment
(:tag (t1 t2 ..)
 :history (h1 h2 ..)
 :custom-1 (u11 u12 ..)
 :custom-2 (u21 u22 ..)
 :.. ..)
#+end_src

** functions

+ [X] root<-file
+ [X] rel-path<-file
+ [X] hash<-file
+ [X] +tag!, -tag!
+ [X] update-file-history!
+ [X] attachment<-file
+ [X] tags-in-repo

* todo lists

+ [ ] Version control everything in the database.
+ [ ] Syntactically abstract with macros +tag/-tag/fetch-tag..
  etc, for the users to write functions for their own slots
  easily.
+ [ ] Attachment editor: use lens/comonads, #'rm-attachment,
  #'cp-attachment.
